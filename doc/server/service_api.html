<!DOCTYPE html>
<html>
<head>
<title>service_api</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>集合/数组/对象的常用功能集</h2>
<p>系统引入了underscore这个开源库，可以直接使用这个库的相应函数。</p>
<p><a href="underscore_doc_v1_7_0.html">查看underscore使用API</a></p>
<h2 id="file_oper">文件操作</h2>
<p><a href="service_file_api.html">查看文件操作API</a></p>
<h2>消息队列</h2>
<ul>
<li><a href="service_mq_js_api.html">查看消息队列API -- JS</a></li>
<li><a href="service_mq_java_api.html">查看消息队列API -- JAVA</a></li>
<li><a href="ActiveMQ_menual.chm">其他手册</a></li>
</ul>
<h2>API</h2>
<h3>日志</h3>
<p>RDK提供了一组记录日志的函数，它们有共同的定义：</p>
<pre><code>function log(msg1, msg2, msg3, ...)；
</code></pre>

<p>参数：</p>
<ul>
<li><code>msg1</code>, <code>msg2</code>, ... 任意对象。可选。RDK会尝试将这些对象转为字符串写入日志中，目前完美支持Date，任意结构的json对象。对其他复杂对象支持不好，不支持Java对象。</li>
</ul>
<p>一共有这些（日志级别由低到高）：</p>
<ul>
<li><code>log()</code> / <code>debug()</code>：记录debug级别的日志</li>
<li><code>info()</code>：记录info级别的日志</li>
<li><code>warn()</code>：记录warn级别的日志</li>
<li><code>error()</code>：记录error级别的日志</li>
<li><code>fatal()</code>：记录fatal级别的日志</li>
<li><code>crit()</code>：记录一些关键日志，级别最高</li>
</ul>
<p>日志生成在app目录下的 server/logs/log.txt 文件内。</p>
<h3><code>kv()</code></h3>
<p>定义：</p>
<pre><code>function kv(map, defaultValue);
</code></pre>

<p>参数：</p>
<ul>
<li>map 一个JS对象。必选。一般来说，是 <code>mapper()</code> 函数的返回值。</li>
<li>defaultValue 一个整数/字符串/布尔。可选，默认值是key本身，即默认返回key值。</li>
</ul>
<p>返回：可用于 <code>matrix()</code> 的列<strong>转换函数</strong>，这个转换函数的作用是返回某个值在入参 <code>map</code> 中的映射。</p>
<p>说明：常常用于对数据集中的某列做国际化，可以参考 <code>matrix()</code> 函数的例子。</p>
<p>示例：某个表中有一个字段用于表示“是否”这样的状态，存在库中，1代表“是”，0代表“否”，可以使用下面的代码得到一个转换函数：</p>
<pre><code>var tranformFunction = kv({1: &quot;是&quot;, 0: &quot;否&quot;});

var val = tranformFunction(0); // &quot;否&quot;
var val = tranformFunction(1); // &quot;是&quot;
var val = tranformFunction(2); // 2
</code></pre>

<p>如果期望在输入非1、0时得到“未知”，则可以使用下面代码</p>
<pre><code>var tranformFunction = kv({1: &quot;是&quot;, 0: &quot;否&quot;}， &quot;未知&quot;);
var val = tranformFunction(2); // &quot;未知&quot;
</code></pre>

<h3><code>mapper()</code></h3>
<p>定义：</p>
<pre><code>function mapper(sql, key, value, keepResultSet);
</code></pre>

<p>参数：</p>
<ul>
<li>sql 一个SQL字符串或者结果集<code>java.sql.ResultSet</code>。必选。</li>
<li>key 一个整数/字符串。必选。结果集中的字段名，或者字段序号（从1开始）。</li>
<li>value 一个整数/字符串。必选。结果集中的字段名，或者字段序号（从1开始）。</li>
<li>
keepResultSet 一个布尔值。可选，默认值是false。
<ul>
<li>为<code>false</code>（默认）： 在返回之前自动清理所占数据库连接和其他数据库资源。</li>
<li>为<code>true</code>：结果集在函数返回后依然可用，但是它所占的数据库连接等不会释放，必须手工调用 <code>clear()</code> 函数释放。<strong>如果没有特别的需要，请不要设置为true！！</strong></li>
<li><strong><span style="color:red">设置为<code>true</code>又没有调用<code>clear()</code>函数清理，可能会导致RDK所有服务不可用！</span></strong></li>
<li>仅在第一个参数是<code>java.sql.ResultSet</code>的时候，此参数才有效。</li>
</ul>
</li>
</ul>
<p>返回：将结果集转为一个映射。</p>
<p>说明：这在需要生成一个国际化键值对的时候非常有用，数据库中保存的大多是对象的id，返回给前端之前，需要将id转为对应的描述字符串，<code>mapper()</code> 可以生成一个键值对保存下来备用。</p>
<pre><code>    var sql = &quot;select neid,name from dim_ne&quot;;
    var map = mapper(sql, 'neid', 'name');
    log(map);
</code></pre>

<p>打印出来的是网元id和网元名称的映射：</p>
<pre><code>{
    &quot;11&quot;:&quot;S11_1&quot;,
    &quot;12&quot;:&quot;S1MME_1&quot;,
    &quot;13&quot;:&quot;S1U_1_DPI&quot;,
    &quot;21&quot;:&quot;S11_1&quot;,
    &quot;22&quot;:&quot;SMME_1&quot;,
    &quot;23&quot;:&quot;S1U_1_DPI&quot;
}
</code></pre>

<p>也可以使用列的索引来指明key和value的字段，下面代码的效果和前面示例的效果一致：</p>
<pre><code>    var sql = &quot;select neid,name from dim_ne&quot;;
    var map = mapper(sql, 1, 2);
    log(map);
</code></pre>

<p>使用索引的作为key和value主要是用于sql不确定的场景。</p>
<h3><code>matrix()</code></h3>
<p>定义：</p>
<pre><code>function matrix(sql, mapIterator, keepResultSet);
</code></pre>

<p>参数：</p>
<ul>
<li>sql 一个SQL字符串或者结果集<code>java.sql.ResultSet</code>。必选。</li>
<li>mapIterator 一个对象/函数。可选。这个参数用于 <code>matrix()</code> 函数转换过程中对指定列进行转换。</li>
<li>
keepResultSet 一个布尔值。可选，默认值是false。
<ul>
<li>为<code>false</code>（默认）： 在返回之前自动清理所占数据库连接和其他数据库资源。</li>
<li>为<code>true</code>：结果集在函数返回后依然可用，但是它所占的数据库连接等不会释放，必须手工调用 <code>clear()</code> 函数释放。<strong>如果没有特别的需要，请不要设置为true！！</strong></li>
<li><strong><span style="color:red">设置为<code>true</code>又没有调用<code>clear()</code>函数清理，可能会导致RDK所有服务不可用！</span></strong></li>
<li>仅在第一个参数是<code>java.sql.ResultSet</code>的时候，此参数才有效。</li>
</ul>
</li>
</ul>
<p>返回：将结果集转为一个RDK前后端通用数据结构，称之为数据矩阵（matrix）。</p>
<p>说明：这个函数是应用最常用的函数之一，<code>sql()</code> 返回的结果集是无法直接传给前端的，必须使用 <code>matrix()</code> 转换之后才能传给前端。</p>
<h4>数据矩阵（matrix）的数据结构</h4>
<p><code>matrix()</code> 返回的数据矩阵的结构如下，这是数据矩阵最基本的结构：</p>
<pre><code>{
    header: ['header1', 'header2', 'header3'],
    field: ['field1', 'field2', 'field3'],
    data: [
            ['data11', 'data12', 'data13'],
            ['data21', 'data22', 'data23'],
            ...
            ['data31', 'data32', 'data33']
        ]
}
</code></pre>

<p>header和field都是一维数组，data是一个二维数组。data的值对应着数据库表的数据，field是data中每一列对应的列头，header是field每个元素对应的国际化。</p>
<h4><code>mapIterator</code> 的使用</h4>
<p><code>mapIterator</code> 用于 <code>matrix()</code> 函数转换过程中对指定列进行转换，它是一个JSON对象，属性为需要转换的列的字段名，值为一个函数，结构如下：</p>
<pre><code>{
    fieldName: function(value, row, index) {...},
    fieldName1: function(value, row, index) {...},
    ...
    fieldName2: function(value, row, index) {...},
}
</code></pre>

<p>实际使用时，需要把fieldName换成实际的字段名。</p>
<p><code>mapIterator</code> 属性值是函数，它描述了需要对fieldName所在列要做的映射逻辑，实现逻辑是把传入的value做一些处理（映射、计算等），然后将处理后的新值返回出来。</p>
<p>看一个实际例子：</p>
<pre><code>var mapIt = {
    neid: function(value, row, index) {
        var newValue = ...;
        return newValue;
    },
    kpi_succ_rate: function(value, row, index) {
        var newValue = ...;
        return newValue;
    }
}
</code></pre>

<p>它会对matrix中的neid和kpi_succ_rate这2列做映射。</p>
<h4>使用 <code>mapIterator</code> 实现字段国际化</h4>
<p>继续前面例子，我们从数据库中查询来的neid是网元的id，我们希望将它转成网元的描述，这样就可以直接显示在界面上了。为了达到这个目的，必须先将网元id与描述的对应关系给查询出来，这个可以参考 <code>mapper()</code> 函数的例子，代码如下：</p>
<pre><code>    var neMap = mapper(&quot;select neid,name from dim_ne&quot;, 'neid', 'name');
</code></pre>

<p>接下来实现转换函数：</p>
<pre><code>var mapIt = {
    neid: function(neid, row, index) {
        var newValue = map[neid];
        return newValue;
    }
}
</code></pre>

<p>非常简单，就是把neid到网元映射表中转成网元描述即可。实际上，RDK框架提供了一个更简单的方式，可以直接使用 <code>kv()</code> 函数：</p>
<pre><code>var mapIt = {
    neid: kv(neMap)
}
</code></pre>

<p><code>kv()</code> 函数会返回一个专门做国际化映射的迭代函数。</p>
<h4>使用 <code>mapIterator</code> 实现字段复杂计算</h4>
<p>再举个需要进行运算的例子。</p>
<p>kpi_succ_rate这一列是某个KPI的值，但是在数据库中并没有直接保存它的值，而是保存了计算它的值所需的计数器，这个时候，我们应该把相关的计数器都查询出来，并写一个这样的迭代函数来计算它的值：</p>
<pre><code>var mapIt = {
    //注意这里row参数的类型是 java.sql.ResultSet
    kpi_succ_rate: function(value, row, index) {
        var successCounter = row.getObject(&quot;succ_counter&quot;);
        var allCounter = row.getObject(&quot;all_counter&quot;);
        var newValue = allCounter == 0 ? 0 : successCounter/allCounter;
        return newValue;
    }
}
</code></pre>

<h4><code>matrix()</code> 例子的完整代码</h4>
<p>到此这个服务就完成了，完整代码如下：</p>
<pre><code>(function() {

return function(request) {
    //先把网元的映射管理准备好
    var sql = &quot;select neid,name from dim_ne&quot;;
    var neMap = mapper(sql, 'neid', 'name');

    var mapIter = {
        //使用kv函数创建一个通用的国际化迭代函数
        neid: kv(neMap),

        //根据算法算出 kpi_succ_rate 的值。
        kpi_succ_rate: function(value, row, index) {
            var successCounter = row.getObject(&quot;succ_counter&quot;);
            var allCounter = row.getObject(&quot;all_counter&quot;);
            var newValue = allCounter == 0 ? 0 : successCounter/allCounter;
            return newValue;
        }
    }

    //查询出基础数据集
    var sql = 'select neid,&quot;&quot; as kpi_succ_rate,succ_counter,all_counter from aggr_xxxx where ...';
    var result = matrix(sql, mapIter);

    //列头部分需要应用自己给出
    result.header = ['网元', '呼叫成功率', '成功次数', '呼叫总次数'];

    return json(result);
}

})();
</code></pre>

<p>这个服务返回了类似下面这样的数据给前端：</p>
<pre><code>{
    header: ['网元', '呼叫成功率', '成功次数', '呼叫总次数'],
    field: ['neid', 'kpi_succ_rate', 'succ_counter','all_counter'],
    data: [
            ['S1MME_1', '98.99', '9899', '10000'],
            ['S1U_1_DPI', '97.44', '9744', '10000'],
            ...
            ['S11_1', '99.44', '9944', '10000']
        ]
}
</code></pre>

<h3><code>sql()</code> <span style="color:red">慎用</span></h3>
<p>定义：</p>
<pre><code>function sql(sql);
</code></pre>

<p>参数：</p>
<ul>
<li>sql 一个SQL字符串。必选。</li>
</ul>
<p>返回：sql执行结果集（<code>java.sql.ResultSet</code>）。</p>
<p>说明：执行一个sql语句，并返回它的结果集。</p>
<p><strong><span style="color:red">结果集使用完之后，务必调用<code>clear()</code>函数清理，否则可能会导致RDK所有服务不可用！</span></strong></p>
<p>结果集是一个java数据类型，读取起来不方便，一般配合 <code>mapper()</code> 和 <code>matrix()</code> 这两个函数一起使用。</p>
<p>返回的结果集是一个java对象，不通过普通的js方式去访问，但是可以通过<code>java.sql.ResultSet</code>提供的方法去访问它，<a href="http://docs.oracle.com/javase/8/docs/api/java/sql/ResultSet.html">详情参考这里</a>。下面给出一个常用的遍历结果集的代码片段：</p>
<pre><code>(function() {

    return function(request, script) {
        //服务的第一行代码写在这里！

        //查询 dim_ne 表
        var rs = sql('select * from dim_ne;')

        //取出元数据
        var metaData = rs.getMetaData();
        //当前的列数
        var cc = metaData.getColumnCount();

        //这里的row依然是一个 ResultSet 对象
        //注意这里each函数会在完毕之后自动关闭rs
        each(rs, function (row, index) {
            log('-----------', index, '-----------')
            for(var i = 1; i &lt;= cc; i++) {
                var str = metaData.getColumnLabel(i) + '=' + rs.getObject(i);
                log(str);
            }
        });

        clear(rs);
        return '';
    }

})();
</code></pre>

<p>该服务在日志中的打印如下：</p>
<pre><code>----------- 0 -----------
neid=11
netype=216
typedesc=S11
ver=0
name=s11
----------- 1 -----------
neid=7
netype=11
typedesc=SGW
ver=0
name=sgw
----------- 2 -----------
neid=42
netype=42
typedesc=MME
ver=0
name=mme
...
</code></pre>

<h3><code>clear()</code></h3>
<p>定义：</p>
<pre><code>function clear(resultSet);
</code></pre>

<p>参数：</p>
<ul>
<li>resultSet 是 <code>sql()</code> 函数的返回值。必选。</li>
</ul>
<p>返回：无。</p>
<p>说明：<code>sql()</code> 函数的返回值是一个Java对象，<code>java.sql.ResultSet</code> 类型。在有特殊需要的时候，可以自行操作结果集，但是请务必在完成之后调用本函数清理掉所占的资源，包括</p>
<ul>
<li>执行本次sql的<strong>数据库连接</strong>；</li>
<li>结果集所占的内存；</li>
</ul>
<p><strong><span style="color:red">结果集使用完之后，务必调用<code>clear()</code>函数清理，否则可能会导致RDK所有服务不可用！</span></strong></p>
<p>请注意在<code>sql()</code>函数和<code>clear()</code>函数之间的代码要做好异常保护，以确保<code>clear()</code>可以被成功调用。</p>
<p>RDK提供了众多的处理结果集的函数，包括 <code>matrix()</code> / <code>mapper()</code> / <code>earch()</code> 等，都会自动清理结果集，无需再次清理。</p>
<h3><code>require()</code></h3>
<p>定义：</p>
<pre><code>function require(script);
</code></pre>

<p>参数：</p>
<ul>
<li>script 一个字符串。待加载的脚本url，可使用<a href="relative_path_rule.html">路径宏</a>简化路径。</li>
</ul>
<p>返回：对应脚本的运行结果。</p>
<p>说明：可以使用 <code>require()</code> 来引入其他的js文件。目标脚本被加载之后会立即运行该脚本，如果有返回值，则通过 <code>require()</code> 的返回值来引用。比如某服务有一个公共函数库mylib.js，代码为：</p>
<pre><code>(function() {
    return {
        hello: function(name) {
            log('hello ' + name);
        }
    }
})();
</code></pre>

<p>则可以这样来引用它</p>
<pre><code>var lib = require('mylib.js');
lib.hello('rdk');
</code></pre>

<p>这个函数有个别名：<code>load()</code>。但请尽量使用 <code>require()</code> 这个名字来调用，万一以后把js引擎改为nodejs，则代码可以不修改。</p>
<h3><code>buffer()</code></h3>
<p>定义：</p>
<pre><code>function buffer(name, dataDescriptor, subject);
</code></pre>

<p>参数：</p>
<ul>
<li>name 一个字符串。必选。缓冲数据的名称。</li>
<li>dataDescriptor 一个对象/函数。必选。需要缓冲的数据或者一个函数用于创建需要缓冲的数据。</li>
<li>subject 一个字符串。变化主题，暂时未用到。</li>
</ul>
<p>返回：<code>dataDescriptor</code> 是一个对象时，返回该对象。<code>dataDescriptor</code> 是一个函数时，返回该函数的返回值。</p>
<p>说明：用于缓存一些数据，当这些数据已经存在，则从缓存中取出并返回，如果不存在，则调用 <code>dataDescriptor</code>，并将其返回值的数据放到缓存中，并返回这些数据。</p>
<p>例子：</p>
<p><code>matrix()</code> 函数中有一个完整的服务实现例子，该例子有个缺陷。网元id和网元名称的映射关系，在系统安装好了后，就几乎没有变化的可能，这些数据我们称为<strong>静态数据</strong>。静态数据我们只需要查询一次就够了，不需要每次都去数据库查询。VMax系统中有很多很多静态数据。该例子并没有考虑到这一点，每次前端的请求过来，都会去查询一次静态数据。</p>
<p>我们来改进这个缺陷，下面是代码：</p>
<pre><code>(function() {

return function(request) {
    //先把网元的映射管理准备好
    var neMap = buffer('neMap', function () {
            var sql = &quot;select neid,name from dim_ne;&quot;;
            return mapper(sql, 'neid', 'name');
        });

    /** 其他的代码不变 **/
    ...

    return json(result);
}

})();
</code></pre>

<p>RDK会尝试去读取名称为 neMap 的缓冲数据</p>
<ul>
<li>如果有，则直接返回；</li>
<li>如果没有，则使用 <code>dataDescriptor</code> 来创建它，并加入缓冲区；</li>
</ul>
<p>这样，自始至终，静态数据只会被初始化一次。</p>
<h4>线程安全性</h4>
<p>当 <code>dataDescriptor</code> 是一个函数时，这个函数的执行是线程安全的，即一旦某个 <code>name</code> 的 <code>dataDescriptor</code> 在运行过程中，其他所有在尝试读取 <code>name</code> 的缓冲数据的任何服务的所有请求，都会阻塞等待此函数的返回后再继续执行。</p>
<p>当 <code>dataDescriptor</code> 是一个对象时，<code>buffer()</code> 只在缓冲区更新的过程是线程安全的，此对象的创建过程的线程安全性由应用自行保证，参考 <code>sync()</code> 函数。</p>
<h4>缓冲区的更新</h4>
<p>RDK提供了 <code>getBuffer()</code> 和 <code>removeBuffer()</code> 这两个函数来处理缓冲区，都是线程安全的。</p>
<ul>
<li><code>getBuffer()</code> 和 <code>buffer()</code> 作用类似，它只读缓冲区，读取失败时不创建任何缓冲数据</li>
<li><code>removeBuffer()</code> 用来删除一个缓冲数据。</li>
</ul>
<p><code>removeBuffer()</code> 的定义是</p>
<pre><code>function removeBuffer(name)
</code></pre>

<h3><code>sync()</code></h3>
<p>定义：</p>
<pre><code>function sync(job, lockName);
</code></pre>

<p>参数：</p>
<ul>
<li>job 一个函数。必选。同步作业函数。</li>
<li>lockName 一个字符串。可选，默认值是全局锁。RDK会使用lockName指明的锁来执行同步作业。</li>
</ul>
<p>返回：<code>job</code> 的返回值。</p>
<p>说明：当一些数据存在不同请求同时处理的时候，需要用到这个函数。尽量的减小锁的粒度以提升性能，尽量避免使用全局锁。</p>
<h3><code>json()</code></h3>
<p>定义：</p>
<pre><code>function json(data, indent);
</code></pre>

<p>参数：</p>
<ul>
<li>data 一个js对象。需要序列化的json对象。必选。</li>
<li>indent 一个字符串。格式化输出时的缩进量。可选，默认值是一些空格。</li>
</ul>
<p>返回：一个json字符串</p>
<p>说明：平时定位问题的时候，需要将对象打印出来，可以使用这个函数：</p>
<pre><code>var data = {key: &quot;value&quot;, arr: [1, 2, 4]}
json(data);
</code></pre>

<p>得到的结果是</p>
<pre><code>{
  &quot;key&quot;: &quot;value&quot;,
  &quot;arr&quot;: [ 1, 2, 4 ]
}
</code></pre>

<h3><code>loadClass()</code></h3>
<p>定义：</p>
<pre><code>function loadClass(jarPath, className);
</code></pre>

<p>参数：</p>
<ul>
<li>jarPath 一个字符串。jar包所在路径，如果是一个jar文件，则只加载该文件，如果是一个目录，则加载该目录下所有的扩展名为jar的文件。可使用<a href="relative_path_rule.html">路径宏</a>简化路径。</li>
<li>className 一个字符串。class的全类名。</li>
</ul>
<p>返回：Java的Class。</p>
<p>说明：应用需要使用到第三方jar包中的类时，可以使用这个函数把类反射出来到js中直接调用： </p>
<pre><code>var myClass = loadClass(&quot;$base/lib&quot;, &quot;com.zte.sql.optimizer.SqlOptimizer&quot;);
var myInst = myClass.newInstance();
var result = myInst.myMethod(...);
</code></pre>

<p>上述代码会把 app/example/server/lib（以example应用为例） 目录下的所有jar包都加载到虚拟机中，并实例出 <code>com.zte.sql.optimizer.SqlOptimizer</code> 这个类的一个实例。</p>
<p>注意：RDK虚拟机的JRE是1.8的，所以在JS中实例化并运行的Java代码，都是在JRE1.8下跑的</p>
<h4>JS与Java互传参数的建议</h4>
<p>JS调用Java方法，原则是只传递基本类型，包括数字（long），字符串（String），不要传递复杂对象，JS也可以传递任意结构到Java，在Java中被映射成ScriptObjectMirror类型，请自行百度这个类的用法。</p>
<p>Java返回数据给JS，原则也是尽量只返回简单类型。当然也可以返回Java类型的对象给JS，在JS中可以调用这个类的所有public方法，比如下面的JS代码：</p>
<pre><code>var myInst = myClass.newInstance();
//假设getHashMap返回一个 java.util.HashMap 对象
var map = myInst.getHashMap();
map.get(&quot;myKey&quot;); //得到HashMap中myKey的值。
map.size(); //得到HashMap的个数
</code></pre>

<p>我们都知道，JS是无类型语言，而Java是强类型语言，所以JS调用Java方法，传递的参数类型要非常注意，否则很容易在Java中找不到匹配的签名方法而导致调用失败。</p>
<p>例如在Java中定义了下面的方法</p>
<pre><code>public void myMethod(boolean flag) {
    //...
}
</code></pre>

<p>使用下面的JS代码，尝试去调用 <code>myMethod()</code> 方法：</p>
<pre><code>var myInst = myClass.newInstance();
//假设myMethod方法要求传递一个布尔型参数
//这行代码报错
var map = myInst.myMethod(true);
</code></pre>

<p>报错的原因是JS的true关键字传递到java中，变成一个long型1，因此虚拟机找不到匹配的签名方法。</p>
<p>这块的建议是：需要JS调用的Java方法，参数尽量定义成Object的，在Java代码去检查参数类型，以确保最大的兼容性。</p>
<h3><code>i18n()</code></h3>
<p>定义：</p>
<pre><code>function i18n(key, param1, param2, ...);
</code></pre>

<p>参数：</p>
<ul>
<li>key 一个字符串或一个字符串数组。必选。国际化标签。</li>
<li>paramN 一个字符串。可选。动态国际化标签的参数。</li>
</ul>
<p>返回：对应的国际化文本或国际化文本数组。</p>
<p>说明：后端的国际化配置文件必须放在应用目录下的 <code>server/i18n.js</code> 文件。</p>
<p>示例：</p>
<pre><code>//静态国际化标签
var label = i18n('hello'); // 你好 RDK

//数组国际化
var label = i18n(['hello','world']); // ['你好','世界'] 

//动态国际化标签
var label = i18n('select', 10); // 选中了 10 个对象
</code></pre>

<h2>日期相关</h2>
<p><a href="service_date_api.html">单击这里</a></p>
<h2>COMMON包相关</h2>
<p><a href="common.html">单击这里</a></p>
<div title="后端服务API" id="__hidden__">
<script src="/doc/tools/doc_js/misc.js"></script>
</div>
</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
