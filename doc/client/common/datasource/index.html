<!DOCTYPE html>
<html>
<head>
<title>DataSourceService</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>数据源</h1>
<p>数据源是RDK中的一个重要概念，它是RDK前后端交互的纽带。</p>
<ul>
<li>它可以请求标准REST服务、非标准REST服务，也可以请求服务器上的静态资源。</li>
<li>可以自动将请求的结果与UI或者控件绑定，应用无需编写一行代码就可以将后端服务结果呈现在界面上。</li>
<li>支持GET/PUT/POST/DELETE 4个HTTP动作分别对应着查询/新增/修改/删除4个动作。</li>
<li>支持发起周期性请求。</li>
</ul>
<h2>创建数据源</h2>
<h3>在DOM上直接创建数据源 <font color=red>推荐</font></h3>
<p>方式1 <strong>推荐</strong>，集成到任意dom节点上。这个方式代码高度内聚，强烈推荐尽量使用这个方式，后续维护起来很方便。</p>
<pre><code>&lt;-- 方式1 推荐，集成到任意dom节点上 --&gt;
&lt;ANY ds=&quot;ds_user&quot; ds_url=&quot;demo/user_list&quot; ds_query_if=&quot;ready&quot;&gt;&lt;/ANY&gt; 
</code></pre>

<p>方式2，使用ds节点。这个方式会污染dom树，不推荐。方式2主要是作为方式1的补充。在一个dom节点上只能用方式1创建一个数据源，如果一个节点需要多个数据源则可以使用方式2来创建数据源，或者使用js创建数据源。</p>
<pre><code>&lt;-- 方式2，使用ds节点 --&gt;
&lt;ds id=&quot;ds_user&quot; url=&quot;demo/user_list&quot; query_if=&quot;ready&quot;&gt;&lt;/ds&gt;
</code></pre>

<h3>在JS代码中创建数据源</h3>
<p>注意：在js中创建出来的数据源<strong>必须赋予scope属性</strong>才能实现双向绑定：</p>
<pre><code>var ds = DataSourceService.create({
    id: 'dsId', //必选，数据源id
    url: '/demo/my_url', //必选，数据源url
    resultHandler: function() {}, //可选，结果处理函数，常用属性
    conditionProcessor: function() {}, //可选，查询条件处理器
    dataProcessor: function() {},      //可选，数据处理器
    queryMethod: 'get',     //可选，查询时使用的http动词
    addMethod: 'put',       //可选，新增时使用的http动词
    updateMethod: 'post',   //可选，更新时使用的http动词
    deleteMethod: 'delete', //可选，删除时使用的http动词
    queryIf: '',    //可选，触发查询的条件
    addIf: '',      //可选，触发添加的条件
    updateIf: '',   //可选，触发修改的条件
    deleteIf: '',   //可选，触发删除的条件
});
//在js中创建出来的数据源必须赋予scope属性才能实现双向绑定
ds.scope = $scope;
</code></pre>

<p>注意上面代码使用到了 <code>DataSourceService</code> 服务，需要将这个服务的依赖注入到应用的控制器中。关于依赖注入，<a href="../dependency_injection.html">请访问这里</a>。</p>
<h2>数据源的使用</h2>
<p>我们可以像使用本地数据一样方便的使用网络上的资源，请看下面例子
<live_demo example="common/datasource/with_select/" width="500" height="40"></live_demo></p>
<h3>属性说明</h3>
<h4><code>ds_id</code> / <code>id</code></h4>
<p>数据源id，访问数据源的标示符，如果使用DOM方式创建数据源，则会在当前 <code>scope</code> 上创建一个与数据源id相同的属性，它的值是数据源调用服务的结果或者 <code>ds_init_data</code> 属性对应的对象。</p>
<h4><code>ds_url</code> / <code>url</code></h4>
<p>数据源对应的服务url。</p>
<h4><code>ds_result_handler</code> / <code>resultHandler</code></h4>
<p><code>scope</code> 上的一个函数，作为数据源结果处理器，数据源访问网络得到结果之后，会调用此属性对应的函数。</p>
<h4><code>ds_init_data</code> / <code>initData</code></h4>
<p>数据源的初始化数据json字符串表达式，RDK会将这个json字符串转为一个json对象。数据源从开始访问网络到获得应答之间有时差，为了页面上有更好的用户体验，可以设置这个值作为数据源得到真正数据之前的提示值，可以防止页面抖动。</p>
<h4><code>ds_condition_processor</code> / <code>conditionProcessor</code></h4>
<p><code>scope</code> 上的一个函数，作为数据源条件处理器，该函数必须返回一个对象作为本次访问网络的条件，在数据源访问网路之前会调用此函数。一般用于对查询条件做细微调整。</p>
<h4><code>ds_data_processor</code> / <code>dataProcessor</code></h4>
<p><code>scope</code> 上的一个函数，作为数据源结果处理器，该函数必须返回一个对象作为本次访问网络的结果，在数据源访问网路得到数据之后会调用此函数。一般用于对服务的原始结果做细微调整。</p>
<h4><code>ds_query_method</code> / <code>queryMethod</code></h4>
<p>字符串，取 get/put/post/delete 这4个值中的一个作为数据源<strong>查询请求</strong>的 HTTP 动词，默认值是get。标准rest服务查询的 HTTP 动词是get。</p>
<h4><code>ds_update_method</code> / <code>updateMethod</code></h4>
<p>字符串，取 get/put/post/delete 这4个值中的一个作为数据源<strong>更新请求</strong>的 HTTP 动词，默认值是post。标准rest服务更新的 HTTP 动词是post。</p>
<h4><code>ds_add_method</code> / <code>addMethod</code></h4>
<p>字符串，取 get/put/post/delete 这4个值中的一个作为数据源<strong>添加请求</strong>的 HTTP 动词，默认值是put。标准rest服务添加的 HTTP 动词是put。</p>
<h4><code>ds_delete_method</code> / <code>deleteMethod</code></h4>
<p>字符串，取 get/put/post/delete 这4个值中的一个作为数据源<strong>删除请求</strong>的 HTTP 动词，默认值是delete。标准rest服务删除的 HTTP 动词是delete。</p>
<ul>
<li><code>ds_query_if</code> / <code>queryIf</code>：一个RDK表达式，用于描述数据触发查询的时机。</li>
<li><code>ds_update_if</code> / <code>updateIf</code>：一个RDK表达式，用于描述数据触发更新的时机。</li>
<li><code>ds_add_if</code> / <code>addIf</code>：一个RDK表达式，用于描述数据触发添加的时机。</li>
<li><code>ds_delete_if</code> / <code>deleteIf</code>：一个RDK表达式，用于描述数据触发删除的时机。</li>
</ul>
<h3>获得数据源的数据</h3>
<p>一般来说，我们无需直接去读取数据源从网络上获取到的数据，RDK的所有控件，双向绑定机制等都已经足够智能去自动取得这些数据了。尽管如此，<code>数据源</code>还是提供了多种途径允许应用自行取得这些数据。</p>
<p><strong>方法1</strong>：访问数据源实例的 <code>data</code> 属性</p>
<pre><code>// ... 让数据源访问网络，获得数据 ...
var ds = DataSourceService.get('my_ds');
var data = ds.data; // data即为数据源的数据了
</code></pre>

<p><strong>方法2</strong>：访问 <code>scope</code> 上以数据源id为键的值</p>
<pre><code>var ds = DataSourceService.create('my_ds', 'my/data/url');
//在js中创建的数据源必须显式赋予scope属性
ds.scope = scope;
// ... 让数据源访问网络，获得数据 ...
var data = scope.my_ds; // data即为数据源的数据了
</code></pre>

<p>注意，在js中创建的数据源如果没有赋予<code>scope</code>属性，则此方法行不通。</p>
<h3>控制数据源触发的时机</h3>
<p>在前面例子中有一个属性 <code>ds_query_if</code> 属性，用它可以控制数据发起查询的时机，下面的代码会让数据源在RDK初始化完成之后立即发起查询：</p>
<pre><code>ds_query_if=&quot;ready&quot;
</code></pre>

<p>除此之外， <code>ds_query_if</code> 还支持更加复杂的表达式：</p>
<pre><code>ds_query_if=&quot;dispatcher.event_type&quot;
</code></pre>

<p>其中，<code>dispatcher</code> 是某个事件发出者，可以是一个控件的id，也可以是一个数据源的id等；<code>event_type</code> 是一个事件类型。</p>
<p>还支持 <code>and</code> 运算，当表达式中的每个事件都发出至少一次之后，当前数据源才会发起查询：</p>
<pre><code>dispatcher1.event_type1 and dispatcher2.event_type2 and ...
</code></pre>

<p>请看一个实例：
<live_demo example="common/datasource/query_if_ready/" width="500" height="110"></live_demo></p>
<p>数据源每个动作都有对应的 if 属性：</p>
<ul>
<li><code>query_if</code>：查询控制</li>
<li><code>add_if</code>：添加控制</li>
<li><code>update_if</code>：更新控制</li>
<li><code>delete_if</code>：删除控制</li>
</ul>
<h3>为数据源添加数据处理器</h3>
<p>当服务端返回的数据结构和控件期望的数据结构有出入的时候，则可以通过 <code>ds_data_processor</code> 属性来实现数据转换，<code>ds_data_processor</code> 的值是 <code>scope</code> 上的函数名。
<live_demo example="common/datasource/data_processor/" width="400" height="90"></live_demo></p>
<h3>为数据源添加结果处理函数</h3>
<p>通过 <code>ds_result_handler</code> 属性可以给数据源添加结果处理函数，<code>ds_result_handler</code> 的值是 <code>scope</code> 上的函数名。当数据源有了结果（成功&amp;失败），都会调用这个函数。这个功能在我们需要手工处理数据源的应答的时候非常有用。</p>
<pre><code>&lt;!-- HTML代码 --&gt;
&lt;any ds=&quot;ds_city&quot; ds_url=&quot;/demo/mock_data/city_list&quot;
    ds_data_processor=&quot;toString&quot;
    ds_result_handler=&quot;showMessage&quot;&gt;
&lt;/any&gt;
</code></pre>

<p><code>ds_result_handler</code> 用起来和 <code>ds_data_processor</code> 很类似，容易混淆，下面是他们的不同之处</p>
<ul>
<li><code>ds_data_processor</code> 是用来对数据源返回的数据进行二次加工的，而 <code>ds_result_handler</code> 是用来当做数据源的结果回调函数用的。</li>
<li><code>ds_data_processor</code> 需要返回一个数据当做数据源的结果，而 <code>ds_result_handler</code> 不需要返回任何结果</li>
<li><code>ds_data_processor</code> 先于 <code>ds_result_handler</code> 被执行</li>
</ul>
<p>下面是例子，注意到数据源先执行了 <code>toString()</code> 把一个复杂结构的数据转成了字符串，然后才调用 <code>showMessage()</code> 将结果 alert 出来。
<live_demo example="common/datasource/result_handler/" width="400" height="40"></live_demo></p>
<p>除了使用 <code>ds_result_handler</code> 添加结果回调的方式，还可以通过<a href="/demo/common/event">事件</a>的方式。每个数据源访问网络有了结果（成功/失败），都会通过数据源id发出一个 <code>result</code> 事件，监听此事件可以处理改数据源的结果。与 <code>ds_result_handler</code> 的方式相比，事件方式更加灵活，可以在代码的不同位置给同一个数据源添加多个事件回调，这样对提高代码的内聚性有帮助。</p>
<pre><code>//下面代码执行的结果和 ds_result_handler 一样
EventService.register('ds_city', 'result', function(event, data) {
    scope.showMessage(data);
});
</code></pre>

<h3>为数据源添加条件处理器</h3>
<p>数据源查询往往是需要带一些查询条件到服务端的，有时候查询条件可能会比较复杂，或者需要做一些转换，或者为不同数据源的条件做一些相同的处理，此时我们会用到条件处理器。条件处理器的使用方法和结果处理器 <code>ds_data_processor</code> 非常类似：</p>
<pre><code>&lt;!-- HTML代码 --&gt;
&lt;any ds=&quot;ds_city&quot; ds_url=&quot;/demo/mock_data/city_list&quot;
    ds_condition_processor=&quot;conditionProcessor&quot; ds_query_if=&quot;ready&quot;&gt;
&lt;/any&gt;

// JS代码
scope.conditionProcessor = function(condition) {
    //入参condition是触发数据源时应用提供的原始条件
    return {con: '这是查询条件'};
}
或者
scope.conditionProcessor = function(condition ，ds) {
    //入参condition是触发数据源时应用提供的原始条件
    //入参ds是执行该条件处理器的数据源实例
    return {con: '这是查询条件'};
}
</code></pre>

<p>提示</p>
<ol>
<li>在使用 <code>ds_query_if</code> 自动发起查询时，<code>ds_condition_processor</code> 会非常有用。</li>
<li>在使用数据源的周期性任务时，<code>ds_condition_processor</code> 会非常有用。</li>
<li>数据源的各种处理器的调用顺序是 <code>ds_condition_processor</code> -&gt; <code>ds_data_processor</code> -&gt; <code>ds_result_handler</code></li>
</ol>
<h3>手工触发数据源的查询</h3>
<p>尽管 <code>ds_query_if</code> 非常有用，但是有时候我们总是想要自己控制数据源发起查询的时机。下面这个例子演示了直接调用数据源实例的 <code>query()</code>/<code>add()</code>/<code>update()</code>/<code>delete()</code> 方法来触发数据源：</p>
<p><live_demo example="common/datasource/result_handler/" width="400" height="40"></live_demo></p>
<p>下面实例代码演示了通过事件的方式触发：</p>
<pre><code>scope.query = function() {
    //事件方式触发数据源
    var conditioin = {};
    EventService.broadcast('ds_city', 'start_query', conditioin);
}
</code></pre>

<p>一共有4个事件：</p>
<ul>
<li><code>start_query</code> 事件，对应数据源的 <code>query()</code></li>
<li><code>start_add</code> 事件，对应数据源的 <code>add()</code></li>
<li><code>start_update</code> 事件，对应数据源的 <code>update()</code></li>
<li><code>start_delete</code> 事件，对应数据源的 <code>delete()</code></li>
<li><code>start_loop</code> 事件，对应数据源的 <code>loop()</code></li>
</ul>
<h3>周期性任务</h3>
<p>在某些场合，需要让数据源定时发起查询，使用 <code>loop()</code> 方法可以启动周期性任务。</p>
<pre><code>//下面的代码会让数据源每2秒钟发起一次查询
//action属性备选：query/add/update/delete
var ds = DataSourceService.get('myid');
ds.loop({action: 'query', interval: 2000});

//同样的，也可以通过事件来触发，效果和调用loop函数完全一致
EventService.broadcast('myid', EventTypes.START_LOOP,
    {action: 'query', interval: 2000});
</code></pre>

<p>提示：周期性任务常常和 <code>ds_condition_processor</code> 配合使用。</p>
<p>在周期性任务完成之后，可以调用 <code>stopLoop()</code> 停止周期性任务。</p>
<pre><code>ds.stopLoop();
</code></pre>

<h3>url模板</h3>
<p>在数据源的目的服务不是标准RESTful服务的时候，需要用到这个功能，差别仅在于url，其他的参数没有区别。下面以一个基于Hibernate实现的服务的url
<br><font style="font-family: Courier New;padding-left:30px">/configureManage/<span style="color:red">overview</span>/<span style="color:green">vipGroup</span><span style="color:blue">Update</span>.do?id=11&amp;<span style="color:red">module=&quot;overview&quot;</span>&amp;value=1111</font><br>
其中带有颜色的部分都是动态的，这个URL的作用是更新某些数据，但是它却是通过HTTP GET的方式发送的。</p>
<p>可以使用下面的url模板解决</p>
<pre><code>//注意url部分
//%module%：读取条件中的module属性，注意到它被两个%包围
//$confItem$：读取条件中的confItem属性，注意到它被两个$包围
//差别是$包围的条件不会再在?后面（即query区）再次出现
var ds = DataSourceService.create('myid', '/configureManage/%module%/$confItem$$action$.do');
//强制让数据源使用get的方式更新数据
ds.updateMethod = 'get';
ds.update({
   module: 'overview',
   confItem: 'vipGroup',
   action: 'Update',
   id: 11,
   value: 1111
});
</code></pre>

<h3>数据源查询流程</h3>
<p>以下为创建数据源并进行数据源查询的流程图，相关定义请参照本文档的<code>在JS代码中创建数据源</code>部分的内容。</p>
<p><img src="数据源查询流程图.PNG" /></p>
<div>
<script data-main="/rdk/app/libs/rdk/rdk" src="/rdk/app/libs/requirejs/require.js"></script>
<script src="/doc/tools/doc_js/main.js"></script>
<script src="/doc/tools/doc_js/misc.js"></script>
</div>
</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
